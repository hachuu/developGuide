# Spring Batch

## spring boot batch 구현 - 2024/03
- 이슈발생 : spring boot 1.5.22 ver => 2.7.18 ver 업데이트하면서 오류 발생
- 오류 내용 : execution = simpleJobLauncher.run(job, jobParameters); 실행 시 Incorrect result size: expected 1, actual 0 에러 발생
- 확인한 내용 : 1.xx ⇒ 2.xx로 넘어올 시 기존 batch 구동 로직이 변경될 수 있음[https://stackoverflow.com/questions/73539723/encountered-fatal-error-executing-job-org-springframework-dao-emptyresultdataac]
    - migration guide 확인 시 batch 내역이 변경되었음을 확인할 수 있었음[https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide]
        
        ```jsx
        **Batch**
        The CommandLineRunner that executes batch jobs on startup has an order of 0.
        ```
        
- *applicationRunner vs CommandLineRunner*[https://www.daleseo.com/spring-boot-runners/]
    - applicationRunner : 기존 @scheduled를 통해 원하는 시간대에 batch실행가능
    - CommandLineRunner : 앱 실행시 자동 구동
- cron에 쓰이는 시간 양식[https://dev-jwblog.tistory.com/133]
- 해결도중 발생한 새로운 이슈 : batch가 2번 실행됨
  - 해결 원인 : ServletInitializer 와 GboxSrvappApplication 에서 중복으로 SpringBootServletInitializer 선언하고 있었음.

- 최종 소스
  ```java
  package batch;
  
  import org.slf4j.Logger;
  import org.slf4j.LoggerFactory;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.beans.factory.annotation.Value;
  import org.springframework.boot.ApplicationArguments;
  import org.springframework.boot.ApplicationRunner;
  import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;
  import org.springframework.scheduling.support.CronTrigger;
  import org.springframework.stereotype.Service;
  
  import java.util.concurrent.ScheduledFuture;
  import com.config.BatchConfig;
  import com.service.Service;
  /**
   * 배치
   */
  @Service
  public class BatchService implements ApplicationRunner {
  
      private static final Logger logger = LoggerFactory.getLogger(BatchService.class);
  
      @Value("${spring.profiles.active}")
      private String activeProfile;
  
      private final ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
      private ScheduledFuture<?> scheduledTask;
  
      @Override
      public void run(ApplicationArguments args) throws Exception {
          // 애플리케이션이 시작될 때 실행할 초기화 로직
          if(!"prod".equals(activeProfile)) {
              logger.info("Spring Boot Batch ApplicationRunner :: is Running");
              testScheduledTaskJustSelect();
              return;
          }
          if(!BatchConfig.isBatchServer()) return;
          startScheduledTaskResetCnt();
      }
  
      /**
       * 주간 카운트 reset하는 batch 함수
       * @Scheduled(cron = "0 50 23 * * 0") 매주 일요일 23:50에 실행
       */
      public void startScheduledTaskResetCnt() {
          scheduler.initialize();
          scheduledTask = scheduler.schedule(new Runnable() {
              @Override
              public void run() {
                  try {
                      scheduledTaskResetCnt();
                  } catch (Exception e) {
                      // 예외 처리
                      logger.error("Scheduled task execution error: " + e.getMessage(), e);
                  }
              }
          }, new CronTrigger("0 50 23 * * 0"));
      }
  
  
      /**
       * @throws Exception
       * 주간 카운트 Reset update xml 실행 (SQL)
       */
      public void scheduledTaskResetCnt() throws Exception {
          logger.info("Scheduled task started! :: scheduledTaskResetCnt");
          Service.resetWeeklyAttendCntAll();
          logger.info("Scheduled task completed! :: scheduledTaskResetCnt");
      }
  
      /**
       * 주간 조회하는 로직
       * @Scheduled(cron = "0 50 23 * * *") 매일 23:50에 실행
       */
      public void testScheduledTaskJustSelect() {
          scheduler.initialize();
          scheduledTask = scheduler.schedule(new Runnable() {
              @Override
              public void run() {
                  try {
                      scheduledTaskJustSelect();
                  } catch (Exception e) {
                      // 예외 처리
                      logger.error("Scheduled task execution error: " + e.getMessage(), e);
                  }
              }
          }, new CronTrigger("0 50 23 * * *"));
      }
  
      /**
       * @throws Exception
       * 출석 조회 xml 실행
       */
      public void scheduledTaskJustSelect() throws Exception {
          logger.info("Scheduled task started! :: scheduledTaskJustSelect");
          Service.testSelectRecentAttendance();
          logger.info("Scheduled task completed! :: scheduledTaskJustSelect");
      }
  }
  
  ```


## 스프링 배치 만들기

배치: **정해진 시간마다 데이터 가공이 필요**한 경우



- [Maven 스프링 배치](https://sodocumentation.net/ko/java/topic/6840/%EC%9E%90%EB%B0%94-%EB%B0%B0%EC%B9%98)

- Gradle 배치

  - [1. Spring Batch 가이드 - 배치 어플리케이션이란?](https://jojoldu.tistory.com/324?category=902551)

  - [2. Spring Batch 가이드 - Batch Job 실행해보기](https://jojoldu.tistory.com/325)

    ```groovy
    dependencies {
        compile('org.springframework.boot:spring-boot-starter-batch')
        compile('org.springframework.boot:spring-boot-starter-data-jpa')
        compile('org.springframework.boot:spring-boot-starter-jdbc')
        runtime('com.h2database:h2')
        runtime('mysql:mysql-connector-java')
        compileOnly('org.projectlombok:lombok')
        testCompile('org.springframework.boot:spring-boot-starter-test')
        testCompile('org.springframework.batch:spring-batch-test')
    }
    ```

    annotation

    - @SpringBootApplication [스프링부트(SpringBoot) @SpringBootApplication](https://m.blog.naver.com/PostView.nhn?blogId=ish430&logNo=221340243322&proxyReferer=https:%2F%2Fwww.google.com%2F)
    - @EnableBatchProcessing (배치기능 활성화)

## Java Persistence API

- [[JPA] JPA란](https://gmlwjd9405.github.io/2019/08/04/what-is-jpa.html)

JPA는 애플리케이션과 JDBC 사이에서 동작

