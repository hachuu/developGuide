1. LLM 이란?
- 대량의 텍스트를 학습해 다음에 올 말을 확률적으로 예측하는 언어 모델
- 질문에 대한 그럴듯한 응답 생성에는 강하지만, 스스로 행동하지는 못함
- 기본적으로 상태,기억,목표가 없는 단발성 응답 구조

2. AI Agent 배경
- LLM의 한계
  - 대화 맥락과 정보를 지속적으로 기억하지 못함
  - 외부 시스템(DB, API, 알림 등)을 직접 제어할 수 없음
  - 목표 달성이나 결과 검증에 대한 책임과 판단 구조가 없음
- AI Agent가 등장한 배경
  - 답변 생성을 넘어 실제 업무를 처리할 AI가 필요해짐
  - LLM에 상태, 도구 사용, 실행 로직을 결합해 행동 가능하게 만듦
  - 반복 작업, 워크플로우, 자동화를 위해 제어 가능한 구조가 요구됨

3. AI Agent란?
- 한줄 요약 : 생각만 하는 AI가 아닌 상황을 이해하고 필요한 일을 나눠서 실제 행동까지 시키는 프로그램 구조
- 목표를 달성하기 위해 "계획(Plan) -> 실행(Act) -> 관찰(Observe) -> 수정(Iterate)"을 반복하는 소프트 웨어
- 단순 챗봇이 "답변 생성"에만 집중한다면, 에이전트는 보통 아래를 포함
  - 도구 사용(Tool calling) : DB 조회, API 호출, 파일 읽기/쓰기, Slack 전송 등
  - 상태(State) : 대화/작업 컨텍스트(세션 메모리), 장기 메모리(지식/기록)
  - 워크플로우(Orchestration) : 어떤 순서로 어떤 작업을 시킬지, 실패 시 재시도/대체 경로
  - 가드레일 : 정책/보안/PII 마스킹, 입력 검증, 비용/시간 제한

4. AI Agent 구조
  1. **Single** : 단순구조
    - 구조
      1. 사용자 입력
      2. LLM이 "생각 + 툴 호출" 결정
      3. 툴 결과 반영해서 최종 답변
    - 한계
      1. 검색, 요약, 분류, 검증, 액션
      2. 실패/지연/비용이 늘음
      3. 테스트/디버깅 어려움
  2. **Multie** : Single 보완, 역할 분리, LLM을 여러번 쓰는 것이 아니라, 책임과 실패 영역을 분리해서 운영이 쉬워짐
    - 구조
      1. Router(분기/의도문류)
      2. Retriever(검색/근거수집)
      3. Planner(계획수립)
      4. Executor(툴 실행)
      5. Verifier(검증/안전/품질)
      6. Summarizer(결과 정리)
      7. Memory Manager(STM/LTM 저장/삭제/회수)

  3. Single에서 멀티로 발전한 이유
    - 하나의 Agent가 모든 역할을 맡으면 복잡도와 실패 리스크가 증가
    - 역할별 Agent 분리 책임, 품질, 디버깅이 쉬워짐
    - 대규모 처리와 확장을 위해 비동기, 분산 구조가 필요해짐
    
  4. Single -> Multie 구조화 단계
     - 단계 A. 역할 분리 + 계약 (Contract)
       - 각 서브 에이전트는 입력/출력 스키마(JSON)를 고정
       - 예 : Retriever는 "근거 목록 + 출처 + 신뢰도"만 반환
       - 장점 : 테스트 가능, 교체 가능
     - 단계 B. 오케스트레이터 도입
       - 중앙 Orchestrator(Manager/Coordinator)를 둡니다.
       - 역할 :
         - 어떤 에이전트를 언제 호출할지 결정
         - 타임아웃/재시도/폴백
         - 상태(세션) 관리
     - 단계 C. 비동기화 + Pub/Sub / Queue로 확장
       요청이 많아지면 동기 체인이 길어져서 느려지고 불안정해짐
       이때 Pub/Sub + Queue 가 들어가짐
       - Pub/Sub(이벤트 브로드캐스트) : "무슨 일이 발생했다"를 여러 소비자에게 알림
       - Queue(작업 대기열) : "일을 처리해라"를 안정적으로 순서/부하조절하며 처리
       * Pub/Sub = 알림(이벤트), Queue = 작업(잡 처리)
     - 단계 D. 상태/메모리 분리
       멀티 에이전트에서 제일 많이 터지는 문제가 "상태 공유"
       - 추천 원칙 : 
         - 세션 상태(STM) : Redis 같은 빠른 저장소
         - 장기 메모리(LTM) : DB/Vector DB(추후 Cosmos DB  확장 계획인 경우)
         - 에이전트들은 각자 메모리 갖고 있지 말고 Memory Service를 통해 읽고 씀

5. 멀티 에이전트의 아키텍처 패턴 3가지
  1. Manager-Worker
    - Manager(오케스트레이터)가 계획 수립
    - Worker 서브 에이전트들이 실행/검색/검증 수행
    - 장점 : 통제가 쉽고 운영/디버깅 용이
    - ex) 대부분의 사내 업무 자동화, 고객응대, 워크플로우
  2. Event-Driven
    - 이벤트 발생 -> 여러 에이전트가 구독해서 각자 처리
    - 장점 : 확장성/느슨한 결합, 기능 추가가 쉬움
    - 단점 : 추적/디버깅(관측성) 없으면 지옥
    - ex) 비동기 파이프라인, 로그/레코드 기반 자동화
  3. Pipeline / DAG
    - 정해진 단계대로 흘러감 (A->B->C)
    - 장점 : 결과 재현/테스트 쉬움
    - 단점 : 예외 케이스 분기 많아지면 복잡
    - ex) 문서 처리(분류->추출->요약->검증), 정형 워크 플로우

6. Pub/Sub VS Queue
```
사용자 메시지 들어옴 -> 콘텐츠인지 판단 -> 웹검색/사내검색 -> 요약 -> 검증 -> Slack 전송/저장
```
- Pub/Sub 이벤트 :
  - MesssageReceived
  - ContentDetected
  - EvidenceCollected
  - DraftReady
  - Verified
- Queue 작업
  - RunDetectionJob
  - RunRetrievalJob
  - RunSummarizeJob
  - RunVerificationJob
  - RunPublishJob
 
7. Sample Architecture
  1. 멀티 에이전트 아키텍처 다이어그램
  2. 서브 에이전트 "입력/출력 JSON 계약(Contract)" 템플릿
  3. 샘플 워크플로우 : "콘텐츠명 추정 -> 검색 -> 요약 -> 검증 -> 공유/저장"
  4. 구현 팁 (Node/Azure에서 "멀티로 갈때" 제일 중요한 것)

  **Sample : "오늘 날씨 무드에 맞는 노래랑 영화 추천"**
  1. 처리 흐름도 (동기 Orchestrator 중심)
  2. 처리 흐름도 (비동기 Pub/Sub + Queue 버전)
  3. 실제 "응답 포맷" 예시 (멀티 에이전트 결과물 느낌)

6. Next AI Agent
